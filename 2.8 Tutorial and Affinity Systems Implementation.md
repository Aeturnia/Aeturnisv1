# Replit Agent Prompt: Step 2.8 - Tutorial & Affinity Systems Implementation

## Objective
Implement comprehensive Tutorial and Affinity tracking systems for Aeturnis Online using strict API/Contract-First methodology with a clean service layer and mock data only.

## Implementation Requirements

### 1. Tutorial Framework

#### Tutorial Zone Creation
- Create a dedicated tutorial zone with boundaries, entry/exit logic, and NPCs
- Implement zone metadata and status tracking
- APIs:
  - `GET /api/v1/tutorial/zone` - Returns tutorial zone information
  - `GET /api/v1/tutorial/status/:characterId` - Returns character's tutorial status

#### Tutorial Quest Chain
- Define linear sequence of at least 3 tutorial quests
- Each quest must have:
  - Step requirements
  - Progression tracking
  - Completion validation
  - Prerequisites
- APIs:
  - `GET /api/v1/tutorial/quests` - Returns all tutorial quests
  - `POST /api/v1/tutorial/progress` - Updates tutorial progress

#### Guided Progression System
- Track current tutorial step per character
- Provide contextual guidance and hints
- Recommend next actions for new players
- API:
  - `GET /api/v1/tutorial/guidance/:characterId` - Returns current guidance

#### Help Message Framework
- Contextual help messages based on tutorial step or gameplay context
- API:
  - `GET /api/v1/tutorial/help?context=...` - Returns relevant help messages

### 2. Affinity Tracking System

#### Weapon Affinity Schema
Define complete schema including:
- Weapon type (sword, axe, bow, staff, etc.)
- Current level (0-100)
- Usage count
- Affinity rank: Novice (0-24), Apprentice (25-49), Journeyman (50-74), Expert (75-99), Master (100)
- Associated bonuses per rank

#### Magic School Affinity
Same schema as weapons for 8+ magic schools:
- Fire, Ice, Lightning, Earth, Arcane, Holy, Shadow, Nature

#### Usage Tracking System
- Track weapon/magic usage per character
- Update affinity levels with simulated progression
- Implement diminishing returns at high levels
- APIs:
  - `POST /api/v1/affinity/weapon/use` - Track weapon usage
  - `POST /api/v1/affinity/magic/use` - Track magic usage
  - Returns: updated level, new rank (if achieved), bonuses

#### Mastery Progression
- Progression milestones at 25/50/75/100
- Rank advancement with titles/badges
- API:
  - `GET /api/v1/affinity/summary/:characterId` - Returns all affinities

## Technical Requirements

### File Structure
```
packages/server/src/
├── types/
│   ├── tutorial.types.ts
│   └── affinity.types.ts
├── services/
│   ├── TutorialService.ts
│   └── AffinityService.ts
├── controllers/
│   ├── tutorial.controller.ts
│   └── affinity.controller.ts
├── routes/
│   ├── tutorial.routes.ts
│   └── affinity.routes.ts
├── providers/
│   └── mock/
│       ├── MockTutorialService.ts
│       └── MockAffinityService.ts
└── __tests__/
    ├── TutorialService.test.ts
    └── AffinityService.test.ts
```

### Type Definitions

Create comprehensive TypeScript interfaces:

```typescript
// tutorial.types.ts
interface TutorialZone {
  id: string;
  name: string;
  description: string;
  boundaries: Boundaries;
  entryRequirements: string[];
  npcs: TutorialNPC[];
}

interface TutorialQuest {
  id: string;
  name: string;
  description: string;
  steps: TutorialStep[];
  prerequisites: string[];
  rewards: TutorialReward[];
}

interface TutorialStatus {
  characterId: string;
  currentQuestId: string;
  currentStepIndex: number;
  completedQuests: string[];
  isComplete: boolean;
}

// affinity.types.ts
interface WeaponAffinity {
  characterId: string;
  weaponType: WeaponType;
  level: number; // 0-100
  usageCount: number;
  rank: AffinityRank;
  bonuses: AffinityBonus[];
}

interface MagicAffinity {
  characterId: string;
  school: MagicSchool;
  level: number;
  usageCount: number;
  rank: AffinityRank;
  bonuses: AffinityBonus[];
}

enum AffinityRank {
  NOVICE = 'novice',
  APPRENTICE = 'apprentice',
  JOURNEYMAN = 'journeyman',
  EXPERT = 'expert',
  MASTER = 'master'
}
```

### Service Implementation

#### TutorialService
- `getTutorialZone()`: Returns tutorial zone data
- `getTutorialStatus(characterId)`: Returns character's tutorial progress
- `getAllQuests()`: Returns all tutorial quests
- `updateProgress(characterId, questId, stepIndex)`: Updates progress
- `getGuidance(characterId)`: Returns contextual guidance
- `getHelp(context)`: Returns help messages

#### AffinityService
- `getAffinitySummary(characterId)`: Returns all affinities
- `trackWeaponUse(characterId, weaponType, usageData)`: Updates weapon affinity
- `trackMagicUse(characterId, school, usageData)`: Updates magic affinity
- `calculateProgression(currentLevel, usageCount)`: Calculates new level with diminishing returns
- `determineRank(level)`: Returns rank based on level
- `calculateBonuses(rank, type)`: Returns bonuses for rank

### Mock Data Requirements

Create comprehensive mock data:
- At least 1 tutorial zone with 3+ NPCs
- 3+ tutorial quests with multiple steps each
- Mock character tutorial statuses
- Mock affinity data for multiple characters
- Progression tables for diminishing returns

### Error Handling

Implement proper error handling for:
- Invalid character IDs
- Quest already completed
- Invalid quest/step combinations
- Affinity already at max level
- Invalid weapon/magic types
- Missing prerequisites

### Testing Requirements

- Unit tests for all service methods
- Test coverage 80%+ for all services
- Mock all external dependencies
- Test error scenarios
- Test progression calculations
- Test rank advancement logic

## Implementation Steps

1. **Create Type Definitions**
   - Define all interfaces in tutorial.types.ts and affinity.types.ts
   - Export all types from types/index.ts

2. **Implement Mock Services**
   - Create MockTutorialService with all mock data
   - Create MockAffinityService with progression logic
   - Ensure all methods return properly typed data

3. **Create Controllers**
   - Implement all endpoint handlers
   - Proper error handling and validation
   - Call only service methods

4. **Define Routes**
   - Set up all API routes with proper middleware
   - Add validation middleware where needed

5. **Write Tests**
   - Comprehensive unit tests for all services
   - Test all edge cases and error scenarios

6. **Self-Audit**
   - Run TypeScript compiler with strict mode
   - Run ESLint with no errors
   - Achieve 80%+ test coverage
   - Include audit results at end of implementation

## Validation Checklist

Before completion, ensure:
- [ ] All APIs return proper JSON responses
- [ ] No TypeScript errors or warnings
- [ ] No ESLint errors
- [ ] Test coverage > 80%
- [ ] All mock data is realistic and comprehensive
- [ ] Error handling covers all edge cases
- [ ] Services use only mock data (no database access)
- [ ] Controllers only call service methods
- [ ] All functions have proper JSDoc comments
- [ ] Diminishing returns algorithm works correctly
- [ ] Rank progression triggers at correct thresholds

## Expected Deliverables

1. All type definition files
2. Service implementations with mock data
3. Controller implementations
4. Route definitions
5. Comprehensive unit tests
6. Self-audit results showing:
   - TypeScript compilation results
   - ESLint results
   - Test coverage report
   - Any warnings or notes

Begin implementation following the strict requirements above. Ensure all code follows TypeScript strict mode with no `any` types or `@ts-ignore` directives.