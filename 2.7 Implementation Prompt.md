# 2.7 Implementation Prompt - World & Movement System

## Context & Objective

Implement Step 2.7: World & Movement for Aeturnis Online following API/Contract-First methodology with strict service layer architecture and comprehensive mock data coverage. This implementation must adhere to all project charter guidelines and SOP requirements.

## System Overview

### Key Subsystems to Implement:

1. **Zone System**
   - World zone definitions with boundaries
   - Movement validation service
   - Zone transition handlers
   - Coordinate system implementation

2. **Progression Tracking**
   - Experience/leveling with BigInt support
   - Skill point allocation system
   - Power scaling algorithms

## Detailed Implementation Requirements

### 1. Zone System

#### Zone Definition Requirements
```typescript
interface Zone {
  id: string;                    // Unique identifier (e.g., "starter_zone")
  displayName: string;           // Human-readable name
  description: string;           // Zone flavor text
  coordinates: {                 // World map position
    x: number;
    y: number;
  };
  boundaries: {                  // Zone boundaries for validation
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
  };
  exits: {                       // Available exit directions
    north?: string;              // Target zone ID
    south?: string;
    east?: string;
    west?: string;
  };
  type: 'normal' | 'city' | 'dungeon' | 'pvp';
  features: string[];            // ["shops", "trainers", "bank", etc.]
  levelRequirement?: number;     // Minimum level to enter
  locked?: boolean;              // For quest-gated zones
}
```

**Mock Data Requirements:**
- Implement at least 6 interconnected zones
- Each zone must have at least 2 valid exits
- Include diverse zone types (starter city, forest, dungeon, etc.)
- All exits must form a navigable world map

#### Movement Validation Service
```typescript
interface MovementValidation {
  canMove(characterId: string, fromZoneId: string, toZoneId: string, direction: Direction): Promise<{
    allowed: boolean;
    reason?: string;
    cooldownRemaining?: number;
  }>;
  
  validateZoneRequirements(characterId: string, targetZoneId: string): Promise<boolean>;
  
  checkMovementCooldown(characterId: string): Promise<number>; // milliseconds remaining
}
```

**Validation Rules:**
- Check if exit exists in requested direction
- Verify character meets level requirements
- Check if zone is locked/quest-gated
- Enforce movement cooldown (2 seconds between moves)
- Validate character is not in combat
- Check for zone-specific restrictions

#### Zone Transition Handler
```typescript
// POST /api/v1/movement/move
interface MoveRequest {
  characterId: string;
  currentZoneId: string;
  direction: 'north' | 'south' | 'east' | 'west';
}

interface MoveResponse {
  success: boolean;
  newZoneId: string;
  zoneInfo: Zone;
  characterPosition: {
    zoneId: string;
    coordinates: { x: number; y: number };
  };
  message: string;
  timestamp: number;
}
```

### 2. Progression Tracking

#### Experience & Leveling System
```typescript
interface CharacterProgression {
  characterId: string;
  level: number;
  experience: bigint;          // Use BigInt for infinite progression
  nextLevelExp: bigint;        // Experience required for next level
  statPoints: number;          // Unallocated stat points
  allocatedStats: {
    strength: number;
    agility: number;
    intelligence: number;
    stamina: number;
  };
}

// Experience curve formula (exponential growth)
function calculateNextLevelExp(level: number): bigint {
  const baseExp = 100n;
  const growthFactor = 115n; // 15% increase per level
  return baseExp * BigInt(level) * growthFactor / 100n;
}
```

#### API Endpoints

**Award Experience:**
```typescript
// POST /api/v1/progression/award-xp
interface AwardXPRequest {
  characterId: string;
  amount: bigint;
  source: string; // "quest", "combat", "exploration", etc.
}

interface AwardXPResponse {
  previousLevel: number;
  newLevel: number;
  previousExp: string;    // BigInt as string
  newExp: string;         // BigInt as string
  nextLevelExp: string;   // BigInt as string
  leveledUp: boolean;
  statPointsGained: number;
  message: string;
}
```

**Allocate Stat Points:**
```typescript
// POST /api/v1/progression/allocate-stat
interface AllocateStatRequest {
  characterId: string;
  stat: 'strength' | 'agility' | 'intelligence' | 'stamina';
  amount: number;
}

interface AllocateStatResponse {
  success: boolean;
  newStats: CharacterStats;
  remainingPoints: number;
  message: string;
}
```

**Power Score Calculation:**
```typescript
// GET /api/v1/progression/power-score/:characterId
interface PowerScoreResponse {
  characterId: string;
  powerScore: number;
  breakdown: {
    levelContribution: number;
    statContribution: number;
    equipmentContribution: number; // Mock value for now
  };
  percentile: number; // Character's power percentile (0-100)
}

// Power score formula
function calculatePowerScore(character: CharacterProgression): number {
  const levelPower = character.level * 10;
  const statPower = (
    character.allocatedStats.strength * 2 +
    character.allocatedStats.agility * 2 +
    character.allocatedStats.intelligence * 2 +
    character.allocatedStats.stamina * 1.5
  );
  const equipmentPower = character.level * 5; // Mock equipment contribution
  
  return Math.floor(levelPower + statPower + equipmentPower);
}
```

## Service Architecture

### File Structure
```
packages/server/src/
├── controllers/
│   ├── zone.controller.ts
│   ├── movement.controller.ts
│   └── progression.controller.ts
├── services/
│   ├── zone.service.ts
│   ├── movement.service.ts
│   └── progression.service.ts
├── types/
│   ├── zone.types.ts
│   ├── movement.types.ts
│   └── progression.types.ts
├── routes/
│   ├── zone.routes.ts
│   ├── movement.routes.ts
│   └── progression.routes.ts
└── __tests__/
    ├── zone.service.test.ts
    ├── movement.service.test.ts
    └── progression.service.test.ts
```

### Service Provider Integration
```typescript
// Register services with the ServiceProvider
ServiceProvider.register('ZoneService', new MockZoneService());
ServiceProvider.register('MovementService', new MockMovementService());
ServiceProvider.register('ProgressionService', new MockProgressionService());
```

## Mock Data Requirements

### Sample Zones
```typescript
const mockZones = [
  {
    id: "starter_city",
    displayName: "Haven's Rest",
    description: "A peaceful city where adventurers begin their journey",
    coordinates: { x: 0, y: 0 },
    boundaries: { minX: -50, maxX: 50, minY: -50, maxY: 50 },
    exits: { north: "forest_edge", east: "trade_road" },
    type: "city",
    features: ["shops", "trainers", "bank", "quest_givers"],
    levelRequirement: 1
  },
  {
    id: "forest_edge",
    displayName: "Whispering Woods Edge",
    description: "The border between civilization and the wild forest",
    coordinates: { x: 0, y: 100 },
    boundaries: { minX: -50, maxX: 50, minY: 50, maxY: 150 },
    exits: { south: "starter_city", north: "deep_forest", east: "goblin_camp" },
    type: "normal",
    features: ["monsters", "gathering_nodes"],
    levelRequirement: 2
  },
  // ... 4 more zones minimum
];
```

### Sample Character Progression
```typescript
const mockCharacter = {
  characterId: "char_001",
  level: 5,
  experience: 2500n,
  nextLevelExp: 690n, // Level 6 requires 690 exp
  statPoints: 2,
  allocatedStats: {
    strength: 8,
    agility: 6,
    intelligence: 5,
    stamina: 6
  }
};
```

## Testing Requirements

### Unit Test Coverage (Minimum 80%)
```typescript
describe('ZoneService', () => {
  it('should return zone details by ID');
  it('should list all zones');
  it('should validate zone boundaries');
  it('should check exit availability');
});

describe('MovementService', () => {
  it('should validate legal movement');
  it('should enforce movement cooldown');
  it('should check level requirements');
  it('should handle locked zones');
  it('should update character position');
});

describe('ProgressionService', () => {
  it('should award experience correctly');
  it('should handle level up events');
  it('should calculate BigInt experience properly');
  it('should allocate stat points');
  it('should prevent over-allocation');
  it('should calculate power score accurately');
});
```

## Error Handling

All services must handle these error cases:
- Invalid zone ID
- Invalid movement direction
- Movement on cooldown
- Insufficient level for zone
- Character not found
- Invalid stat allocation
- Negative experience values
- BigInt overflow protection

## Implementation Checklist

- [ ] Define all TypeScript interfaces and types
- [ ] Implement ZoneService with mock data
- [ ] Implement MovementService with validation logic
- [ ] Implement ProgressionService with BigInt support
- [ ] Create all required controllers
- [ ] Set up Express routes
- [ ] Write comprehensive unit tests
- [ ] Ensure 80%+ test coverage
- [ ] Zero TypeScript errors
- [ ] Document all functions with JSDoc
- [ ] Add services to ServiceProvider
- [ ] Create README with API documentation

## Self-Audit Requirements

At the end of implementation, include:
```
=== Self-Audit Footer ===
TypeScript Errors: 0
ESLint Warnings: 0
Test Coverage:
  - Statements: 85%
  - Branches: 82%
  - Functions: 90%
  - Lines: 85%
All Tests: PASS (45 tests, 0 failures)
===
```

## Additional Notes

- Use existing ServiceProvider pattern for dependency injection
- Leverage existing auth middleware for character ownership validation
- Ensure all BigInt values are serialized as strings in JSON responses
- Mock data should be realistic and internally consistent
- All timestamps should use Date.now() for consistency
- Consider future database schema when designing mock data structures

## Delivery Format

Provide complete implementation with:
1. All service files with comprehensive mock implementations
2. All controller files with proper error handling
3. All route definitions with middleware
4. Complete type definitions
5. Full test suite with >80% coverage
6. API documentation in code comments
7. Self-audit footer showing zero errors and test results