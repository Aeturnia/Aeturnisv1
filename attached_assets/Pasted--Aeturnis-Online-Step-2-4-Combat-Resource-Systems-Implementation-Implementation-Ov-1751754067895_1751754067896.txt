# 🎮 Aeturnis Online - Step 2.4: Combat & Resource Systems Implementation

## 💡 Implementation Overview
Implement a **contract-first, turn-based combat system** with resource pool management (HP/Mana/Stamina). This phase establishes the API surface and socket event contracts, using mocked logic that can be progressively enhanced without breaking client compatibility.

### Architecture Pattern:
- **API-First**: Define contracts before implementation
- **Mock-First**: Stub responses to validate interface design
- **Progressive Enhancement**: Real logic added beneath stable API surface
- **Outside-In**: Start from client needs, work toward backend implementation

---

## 🧱 File Targets

### New Files to Create:
```
/src/types/combat.types.ts
/src/types/resources.types.ts
/src/controllers/combat.controller.ts
/src/services/combat.service.ts
/src/services/resource.service.ts
/src/sockets/combat.socket.ts
/src/routes/combat.routes.ts
/src/middleware/combat.middleware.ts
/src/repositories/combat.repository.ts
/src/utils/combat.utils.ts
```

### Modified Files:
```
/src/sockets/index.ts (register combat handlers)
/src/routes/index.ts (mount combat routes)
/src/types/index.ts (export new types)
```

---

## 📋 Implementation Steps

### Step 1: Define Type Contracts

**`/src/types/resources.types.ts`**
```typescript
export interface ResourcePool {
  hp: number;
  maxHp: number;
  mana: number;
  maxMana: number;
  stamina: number;
  maxStamina: number;
  hpRegenRate: number;
  manaRegenRate: number;
  staminaRegenRate: number;
  lastRegenTime: number; // Unix timestamp
}

export interface ResourceUpdate {
  charId: string;
  poolType: 'hp' | 'mana' | 'stamina';
  currentValue: number;
  maxValue: number;
  change: number; // positive for gain, negative for loss
  reason: string; // 'combat', 'regen', 'item', 'skill'
}
```

**`/src/types/combat.types.ts`**
```typescript
export enum CombatActionType {
  ATTACK = 'attack',
  DEFEND = 'defend',
  FLEE = 'flee',
  USE_ITEM = 'useItem',
  USE_SKILL = 'useSkill',
  PASS = 'pass'
}

export interface CombatAction {
  type: CombatActionType;
  targetCharId?: string;
  itemId?: string;
  skillId?: string;
  timestamp: number;
}

export interface CombatSession {
  sessionId: string;
  participants: CombatParticipant[];
  turnOrder: string[]; // Array of charIds
  currentTurnIndex: number;
  roundNumber: number;
  status: 'active' | 'completed' | 'abandoned';
  startTime: number;
  endTime?: number;
  winner?: string; // charId or 'draw'
}

export interface CombatParticipant {
  charId: string;
  charName: string;
  hp: number;
  maxHp: number;
  mana: number;
  maxMana: number;
  stamina: number;
  maxStamina: number;
  team: 'player' | 'enemy' | 'neutral';
  status: 'active' | 'defeated' | 'fled';
  buffs: CombatBuff[];
  debuffs: CombatDebuff[];
}

export interface CombatBuff {
  id: string;
  name: string;
  duration: number; // turns remaining
  modifier: number; // percentage or flat value
}

export interface CombatDebuff extends CombatBuff {}

export interface CombatResult {
  sessionId: string;
  action: CombatAction;
  actorId: string;
  targetId?: string;
  damage?: number;
  healing?: number;
  resourceCost?: ResourceUpdate[];
  statusEffects?: Array<CombatBuff | CombatDebuff>;
  message: string;
  nextTurnCharId: string;
}

export interface CharacterCombatStats {
  charId: string;
  level: number;
  attack: number;
  defense: number;
  speed: number;
  critRate: number;
  critDamage: number;
  resources: ResourcePool;
}
```

### Step 2: REST API Contract

**`/src/routes/combat.routes.ts`**
```typescript
import { Router } from 'express';
import { authenticateToken } from '../middleware/auth.middleware';
import { validateCombatAction } from '../middleware/combat.middleware';
import * as combatController from '../controllers/combat.controller';

const router = Router();

// Combat session endpoints
router.post('/start', authenticateToken, combatController.startCombat);
router.get('/session/:sessionId', authenticateToken, combatController.getSession);
router.post('/action', authenticateToken, validateCombatAction, combatController.performAction);
router.post('/flee/:sessionId', authenticateToken, combatController.fleeCombat);

// Resource endpoints
router.get('/stats/:charId', authenticateToken, combatController.getCharacterStats);
router.get('/resources/:charId', authenticateToken, combatController.getResources);

// Development/QA endpoints
if (process.env.NODE_ENV !== 'production') {
  router.post('/simulate', authenticateToken, combatController.simulateCombat);
}

export default router;
```

### Step 3: Socket Event Handlers

**`/src/sockets/combat.socket.ts`**
```typescript
import { Server, Socket } from 'socket.io';
import { authenticateSocket } from '../middleware/socket.middleware';
import { CombatService } from '../services/combat.service';
import { CombatAction, CombatResult } from '../types/combat.types';

export function registerCombatHandlers(io: Server): void {
  const combatService = new CombatService();

  io.on('connection', (socket: Socket) => {
    // Join combat room
    socket.on('combat:join', async (data: { sessionId: string }) => {
      try {
        const { sessionId } = data;
        const userId = socket.data.userId;
        
        // Validate user is part of this combat
        const isParticipant = await combatService.validateParticipant(sessionId, userId);
        if (!isParticipant) {
          socket.emit('combat:error', { message: 'Not a participant in this combat' });
          return;
        }

        socket.join(`combat:${sessionId}`);
        socket.emit('combat:joined', { sessionId });
        
        // Send current combat state
        const session = await combatService.getSession(sessionId);
        socket.emit('combat:state', session);
      } catch (error) {
        socket.emit('combat:error', { message: 'Failed to join combat' });
      }
    });

    // Handle combat actions
    socket.on('combat:action', async (data: { sessionId: string; action: CombatAction }) => {
      try {
        const { sessionId, action } = data;
        const userId = socket.data.userId;

        // Process action (mocked for now)
        const result = await combatService.processAction(sessionId, userId, action);
        
        // Broadcast result to all participants
        io.to(`combat:${sessionId}`).emit('combat:result', result);
        
        // Check for combat end
        const session = await combatService.getSession(sessionId);
        if (session.status === 'completed') {
          io.to(`combat:${sessionId}`).emit('combat:end', {
            winner: session.winner,
            rewards: [] // TODO: Implement rewards
          });
        }
      } catch (error) {
        socket.emit('combat:error', { message: 'Invalid action' });
      }
    });

    // Resource updates (real-time)
    socket.on('combat:resource:update', async (data: { charId: string }) => {
      const resources = await combatService.getCharacterResources(data.charId);
      socket.emit('combat:resource:state', resources);
    });
  });
}
```

### Step 4: Mock Service Implementation

**`/src/services/combat.service.ts`**
```typescript
import { v4 as uuidv4 } from 'uuid';
import { 
  CombatSession, 
  CombatAction, 
  CombatResult, 
  CharacterCombatStats,
  CombatParticipant 
} from '../types/combat.types';
import { ResourcePool } from '../types/resources.types';
import { ResourceService } from './resource.service';
import { CombatRepository } from '../repositories/combat.repository';

export class CombatService {
  private resourceService: ResourceService;
  private combatRepo: CombatRepository;
  
  // In-memory session storage for mocking
  private sessions: Map<string, CombatSession> = new Map();

  constructor() {
    this.resourceService = new ResourceService();
    this.combatRepo = new CombatRepository();
  }

  async startCombat(initiatorId: string, targetIds: string[]): Promise<CombatSession> {
    const sessionId = uuidv4();
    
    // Mock participants
    const participants: CombatParticipant[] = [
      {
        charId: initiatorId,
        charName: `Player_${initiatorId.slice(0, 4)}`,
        hp: 100,
        maxHp: 100,
        mana: 50,
        maxMana: 50,
        stamina: 30,
        maxStamina: 30,
        team: 'player',
        status: 'active',
        buffs: [],
        debuffs: []
      },
      ...targetIds.map(id => ({
        charId: id,
        charName: `Enemy_${id.slice(0, 4)}`,
        hp: 80,
        maxHp: 80,
        mana: 30,
        maxMana: 30,
        stamina: 20,
        maxStamina: 20,
        team: 'enemy' as const,
        status: 'active' as const,
        buffs: [],
        debuffs: []
      }))
    ];

    // Determine turn order (mock: based on speed stat)
    const turnOrder = participants.map(p => p.charId);

    const session: CombatSession = {
      sessionId,
      participants,
      turnOrder,
      currentTurnIndex: 0,
      roundNumber: 1,
      status: 'active',
      startTime: Date.now()
    };

    this.sessions.set(sessionId, session);
    
    // TODO: Persist to database
    // await this.combatRepo.createSession(session);

    return session;
  }

  async processAction(
    sessionId: string, 
    userId: string, 
    action: CombatAction
  ): Promise<CombatResult> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error('Combat session not found');
    }

    // Mock validation
    const currentCharId = session.turnOrder[session.currentTurnIndex];
    const actor = session.participants.find(p => p.charId === currentCharId);
    
    if (!actor || actor.charId !== userId) {
      throw new Error('Not your turn');
    }

    // Mock combat result
    const result: CombatResult = {
      sessionId,
      action,
      actorId: actor.charId,
      targetId: action.targetCharId,
      damage: Math.floor(Math.random() * 20) + 10, // 10-30 damage
      resourceCost: [
        {
          charId: actor.charId,
          poolType: 'stamina',
          currentValue: actor.stamina - 5,
          maxValue: actor.maxStamina,
          change: -5,
          reason: 'combat'
        }
      ],
      message: `${actor.charName} attacks for damage!`,
      nextTurnCharId: this.getNextTurnCharId(session)
    };

    // Update session state (mocked)
    if (action.type === 'attack' && action.targetCharId) {
      const target = session.participants.find(p => p.charId === action.targetCharId);
      if (target) {
        target.hp -= result.damage || 0;
        if (target.hp <= 0) {
          target.hp = 0;
          target.status = 'defeated';
        }
      }
    }

    // Advance turn
    session.currentTurnIndex = (session.currentTurnIndex + 1) % session.turnOrder.length;
    if (session.currentTurnIndex === 0) {
      session.roundNumber++;
    }

    // Check win condition
    const activeTeams = new Set(
      session.participants
        .filter(p => p.status === 'active')
        .map(p => p.team)
    );

    if (activeTeams.size === 1) {
      session.status = 'completed';
      session.endTime = Date.now();
      session.winner = session.participants.find(p => p.status === 'active')?.charId;
    }

    return result;
  }

  async getSession(sessionId: string): Promise<CombatSession | null> {
    // Mock: return from memory
    return this.sessions.get(sessionId) || null;
  }

  async validateParticipant(sessionId: string, userId: string): Promise<boolean> {
    const session = this.sessions.get(sessionId);
    if (!session) return false;
    
    return session.participants.some(p => p.charId === userId);
  }

  async getCharacterStats(charId: string): Promise<CharacterCombatStats> {
    // Mock stats
    return {
      charId,
      level: 10,
      attack: 25,
      defense: 20,
      speed: 15,
      critRate: 0.1,
      critDamage: 1.5,
      resources: {
        hp: 100,
        maxHp: 100,
        mana: 50,
        maxMana: 50,
        stamina: 30,
        maxStamina: 30,
        hpRegenRate: 1,
        manaRegenRate: 0.5,
        staminaRegenRate: 2,
        lastRegenTime: Date.now()
      }
    };
  }

  async getCharacterResources(charId: string): Promise<ResourcePool> {
    return this.resourceService.getResources(charId);
  }

  private getNextTurnCharId(session: CombatSession): string {
    const nextIndex = (session.currentTurnIndex + 1) % session.turnOrder.length;
    return session.turnOrder[nextIndex];
  }
}
```

### Step 5: Resource Service

**`/src/services/resource.service.ts`**
```typescript
import { ResourcePool, ResourceUpdate } from '../types/resources.types';
import { Redis } from 'ioredis';
import { getRedisClient } from '../database/redis';

export class ResourceService {
  private redis: Redis;
  private regenIntervals: Map<string, NodeJS.Timeout> = new Map();

  constructor() {
    this.redis = getRedisClient();
  }

  async getResources(charId: string): Promise<ResourcePool> {
    const key = `resources:${charId}`;
    const cached = await this.redis.get(key);
    
    if (cached) {
      const resources = JSON.parse(cached);
      // Apply regeneration
      return this.applyRegeneration(resources);
    }

    // Mock default resources
    const defaultResources: ResourcePool = {
      hp: 100,
      maxHp: 100,
      mana: 50,
      maxMana: 50,
      stamina: 30,
      maxStamina: 30,
      hpRegenRate: 1,
      manaRegenRate: 0.5,
      staminaRegenRate: 2,
      lastRegenTime: Date.now()
    };

    await this.redis.setex(key, 3600, JSON.stringify(defaultResources));
    return defaultResources;
  }

  async updateResource(update: ResourceUpdate): Promise<ResourcePool> {
    const resources = await this.getResources(update.charId);
    
    switch (update.poolType) {
      case 'hp':
        resources.hp = Math.max(0, Math.min(resources.maxHp, update.currentValue));
        break;
      case 'mana':
        resources.mana = Math.max(0, Math.min(resources.maxMana, update.currentValue));
        break;
      case 'stamina':
        resources.stamina = Math.max(0, Math.min(resources.maxStamina, update.currentValue));
        break;
    }

    resources.lastRegenTime = Date.now();
    
    const key = `resources:${update.charId}`;
    await this.redis.setex(key, 3600, JSON.stringify(resources));
    
    // Emit update event
    await this.redis.publish('resource:update', JSON.stringify({
      charId: update.charId,
      resources,
      update
    }));

    return resources;
  }

  private applyRegeneration(resources: ResourcePool): ResourcePool {
    const now = Date.now();
    const timeDiff = (now - resources.lastRegenTime) / 1000; // seconds
    
    if (timeDiff < 1) return resources; // No regen for less than 1 second

    const regenTicks = Math.floor(timeDiff / 5); // Regen every 5 seconds
    
    if (regenTicks > 0) {
      resources.hp = Math.min(
        resources.maxHp, 
        resources.hp + (resources.hpRegenRate * regenTicks)
      );
      resources.mana = Math.min(
        resources.maxMana, 
        resources.mana + (resources.manaRegenRate * regenTicks)
      );
      resources.stamina = Math.min(
        resources.maxStamina, 
        resources.stamina + (resources.staminaRegenRate * regenTicks)
      );
      resources.lastRegenTime = now;
    }

    return resources;
  }

  startRegeneration(charId: string): void {
    // Clear existing interval
    this.stopRegeneration(charId);

    const interval = setInterval(async () => {
      const resources = await this.getResources(charId);
      const updated = this.applyRegeneration(resources);
      
      if (JSON.stringify(resources) !== JSON.stringify(updated)) {
        const key = `resources:${charId}`;
        await this.redis.setex(key, 3600, JSON.stringify(updated));
        
        // Notify about regen
        await this.redis.publish('resource:regen', JSON.stringify({
          charId,
          resources: updated
        }));
      }
    }, 5000); // Check every 5 seconds

    this.regenIntervals.set(charId, interval);
  }

  stopRegeneration(charId: string): void {
    const interval = this.regenIntervals.get(charId);
    if (interval) {
      clearInterval(interval);
      this.regenIntervals.delete(charId);
    }
  }
}
```

### Step 6: Controller Implementation

**`/src/controllers/combat.controller.ts`**
```typescript
import { Request, Response } from 'express';
import { CombatService } from '../services/combat.service';
import { validateCombatAction } from '../utils/combat.utils';

const combatService = new CombatService();

export async function startCombat(req: Request, res: Response): Promise<void> {
  try {
    const { targetIds } = req.body;
    const userId = req.user!.userId;

    if (!targetIds || !Array.isArray(targetIds) || targetIds.length === 0) {
      res.status(400).json({ error: 'Invalid target IDs' });
      return;
    }

    const session = await combatService.startCombat(userId, targetIds);
    
    res.status(201).json({
      success: true,
      sessionId: session.sessionId,
      session
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to start combat' });
  }
}

export async function getSession(req: Request, res: Response): Promise<void> {
  try {
    const { sessionId } = req.params;
    const session = await combatService.getSession(sessionId);

    if (!session) {
      res.status(404).json({ error: 'Session not found' });
      return;
    }

    res.json({ success: true, session });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch session' });
  }
}

export async function performAction(req: Request, res: Response): Promise<void> {
  try {
    const { sessionId, action } = req.body;
    const userId = req.user!.userId;

    const result = await combatService.processAction(sessionId, userId, action);
    
    res.json({ success: true, result });
  } catch (error: any) {
    res.status(400).json({ error: error.message || 'Invalid action' });
  }
}

export async function fleeCombat(req: Request, res: Response): Promise<void> {
  try {
    const { sessionId } = req.params;
    const userId = req.user!.userId;

    const action = {
      type: 'flee' as const,
      timestamp: Date.now()
    };

    const result = await combatService.processAction(sessionId, userId, action);
    
    res.json({ success: true, result });
  } catch (error) {
    res.status(400).json({ error: 'Failed to flee combat' });
  }
}

export async function getCharacterStats(req: Request, res: Response): Promise<void> {
  try {
    const { charId } = req.params;
    const stats = await combatService.getCharacterStats(charId);
    
    res.json({ success: true, stats });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch character stats' });
  }
}

export async function getResources(req: Request, res: Response): Promise<void> {
  try {
    const { charId } = req.params;
    const resources = await combatService.getCharacterResources(charId);
    
    res.json({ success: true, resources });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch resources' });
  }
}

export async function simulateCombat(req: Request, res: Response): Promise<void> {
  try {
    const { attackerId, defenderId, rounds = 10 } = req.body;
    
    // Mock simulation
    const results = [];
    for (let i = 0; i < rounds; i++) {
      results.push({
        round: i + 1,
        damage: Math.floor(Math.random() * 30) + 10,
        critical: Math.random() < 0.1
      });
    }

    res.json({ 
      success: true, 
      simulation: {
        attackerId,
        defenderId,
        rounds,
        results,
        totalDamage: results.reduce((sum, r) => sum + r.damage, 0)
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Simulation failed' });
  }
}
```

---

## 🧪 Validation Rules

### Combat Action Validation
```typescript
// /src/middleware/combat.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { CombatActionType } from '../types/combat.types';

export function validateCombatAction(req: Request, res: Response, next: NextFunction): void {
  const { action } = req.body;

  if (!action || !action.type) {
    res.status(400).json({ error: 'Missing action or action type' });
    return;
  }

  const validTypes = Object.values(CombatActionType);
  if (!validTypes.includes(action.type)) {
    res.status(400).json({ error: 'Invalid action type' });
    return;
  }

  // Type-specific validation
  switch (action.type) {
    case CombatActionType.ATTACK:
      if (!action.targetCharId) {
        res.status(400).json({ error: 'Attack requires targetCharId' });
        return;
      }
      break;
    case CombatActionType.USE_ITEM:
      if (!action.itemId) {
        res.status(400).json({ error: 'UseItem requires itemId' });
        return;
      }
      break;
    case CombatActionType.USE_SKILL:
      if (!action.skillId) {
        res.status(400).json({ error: 'UseSkill requires skillId' });
        return;
      }
      break;
  }

  next();
}
```

### Resource Bounds Validation
- HP: 0 ≤ hp ≤ maxHp
- Mana: 0 ≤ mana ≤ maxMana
- Stamina: 0 ≤ stamina ≤ maxStamina
- Regen rates: 0 ≤ rate ≤ 10
- All numeric values must be integers

---

## 🔁 Event & Real-Time Logic

### Socket Events
| Event | Direction | Payload | Description |
|-------|-----------|---------|-------------|
| `combat:join` | Client→Server | `{ sessionId }` | Join combat room |
| `combat:joined` | Server→Client | `{ sessionId }` | Confirm room joined |
| `combat:state` | Server→Client | `CombatSession` | Full combat state |
| `combat:action` | Client→Server | `{ sessionId, action }` | Submit action |
| `combat:result` | Server→Client | `CombatResult` | Action outcome |
| `combat:error` | Server→Client | `{ message }` | Error notification |
| `combat:end` | Server→Client | `{ winner, rewards }` | Combat ended |
| `combat:resource:update` | Client→Server | `{ charId }` | Request resource state |
| `combat:resource:state` | Server→Client | `ResourcePool` | Current resources |

### Redis Pub/Sub Events
```typescript
// Published to 'resource:update' channel
{
  charId: string;
  resources: ResourcePool;
  update: ResourceUpdate;
}

// Published to 'resource:regen' channel
{
  charId: string;
  resources: ResourcePool;
}
```

---

## 🧪 Example Test Cases

**`/src/__tests__/services/combat.service.test.ts`**
```typescript
import { CombatService } from '../../services/combat.service';
import { CombatActionType } from '../../types/combat.types';

describe('CombatService', () => {
  let combatService: CombatService;

  beforeEach(() => {
    combatService = new CombatService();
  });

  describe('startCombat', () => {
    it('should create a new combat session', async () => {
      const initiatorId = 'player123';
      const targetIds = ['enemy456'];

      const session = await combatService.startCombat(initiatorId, targetIds);

      expect(session).toBeDefined();
      expect(session.sessionId).toBeTruthy();
      expect(session.participants).toHaveLength(2);
      expect(session.status).toBe('active');
      expect(session.currentTurnIndex).toBe(0);
    });

    it('should set correct participant teams', async () => {
      const session = await combatService.startCombat('player1', ['enemy1', 'enemy2']);
      
      const player = session.participants.find(p => p.charId === 'player1');
      const enemies = session.participants.filter(p => p.team === 'enemy');

      expect(player?.team).toBe('player');
      expect(enemies).toHaveLength(2);
    });
  });

  describe('processAction', () => {
    it('should process attack action', async () => {
      const session = await combatService.startCombat('player1', ['enemy1']);
      const action = {
        type: CombatActionType.ATTACK,
        targetCharId: 'enemy1',
        timestamp: Date.now()
      };

      const result = await combatService.processAction(
        session.sessionId,
        'player1',
        action
      );

      expect(result.action).toEqual(action);
      expect(result.damage).toBeGreaterThan(0);
      expect(result.resourceCost).toBeDefined();
      expect(result.resourceCost![0].poolType).toBe('stamina');
    });

    it('should reject action from wrong player', async () => {
      const session = await combatService.startCombat('player1', ['enemy1']);
      const action = {
        type: CombatActionType.ATTACK,
        targetCharId: 'player1',
        timestamp: Date.now()
      };

      await expect(
        combatService.processAction(session.sessionId, 'enemy1', action)
      ).rejects.toThrow('Not your turn');
    });

    it('should detect combat end on defeat', async () => {
      const session = await combatService.startCombat('player1', ['enemy1']);
      
      // Mock enemy to low HP
      const enemy = session.participants.find(p => p.charId === 'enemy1');
      if (enemy) enemy.hp = 1;

      const action = {
        type: CombatActionType.ATTACK,
        targetCharId: 'enemy1',
        timestamp: Date.now()
      };

      await combatService.processAction(session.sessionId, 'player1', action);
      
      const updatedSession = await combatService.getSession(session.sessionId);
      expect(updatedSession?.status).toBe('completed');
      expect(updatedSession?.winner).toBe('player1');
    });
  });
});
```

**`/src/__tests__/services/resource.service.test.ts`**
```typescript
import { ResourceService } from '../../services/resource.service';
import { getRedisClient } from '../../database/redis';

jest.mock('../../database/redis');

describe('ResourceService', () => {
  let resourceService: ResourceService;
  let mockRedis: any;

  beforeEach(() => {
    mockRedis = {
      get: jest.fn(),
      setex: jest.fn(),
      publish: jest.fn()
    };
    (getRedisClient as jest.Mock).mockReturnValue(mockRedis);
    resourceService = new ResourceService();
  });

  describe('getResources', () => {
    it('should return cached resources', async () => {
      const cachedResources = {
        hp: 80,
        maxHp: 100,
        mana: 40,
        maxMana: 50,
        stamina: 20,
        maxStamina: 30,
        hpRegenRate: 1,
        manaRegenRate: 0.5,
        staminaRegenRate: 2,
        lastRegenTime: Date.now() - 10000
      };

      mockRedis.get.mockResolvedValue(JSON.stringify(cachedResources));

      const resources = await resourceService.getResources('char123');
      
      expect(resources.hp).toBeGreaterThan(80); // Should apply regen
      expect(mockRedis.get).toHaveBeenCalledWith('resources:char123');
    });

    it('should create default resources if not cached', async () => {
      mockRedis.get.mockResolvedValue(null);

      const resources = await resourceService.getResources('char123');

      expect(resources.hp).toBe(100);
      expect(resources.mana).toBe(50);
      expect(resources.stamina).toBe(30);
      expect(mockRedis.setex).toHaveBeenCalled();
    });
  });

  describe('updateResource', () => {
    it('should update HP within bounds', async () => {
      mockRedis.get.mockResolvedValue(JSON.stringify({
        hp: 50,
        maxHp: 100,
        mana: 50,
        maxMana: 50,
        stamina: 30,
        maxStamina: 30,
        hpRegenRate: 1,
        manaRegenRate: 0.5,
        staminaRegenRate: 2,
        lastRegenTime: Date.now()
      }));

      const update = {
        charId: 'char123',
        poolType: 'hp' as const,
        currentValue: 150, // Over max
        maxValue: 100,
        change: 100,
        reason: 'item'
      };

      const result = await resourceService.updateResource(update);

      expect(result.hp).toBe(100); // Capped at max
      expect(mockRedis.publish).toHaveBeenCalled();
    });
  });
});
```

---

## 🚧 Edge Cases

1. **Simultaneous Actions**: Use session locks or turn validation to prevent race conditions
2. **Disconnection During Combat**: 
   - Auto-pass turn after timeout (30 seconds)
   - Allow reconnection within 2 minutes
3. **Resource Overflow/Underflow**: Always clamp values to valid ranges
4. **Invalid Targets**: Validate target is in same combat session and alive
5. **Skill/Item Availability**: Check cooldowns and inventory (future enhancement)
6. **Team Damage**: Prevent friendly fire unless specific skill allows it
7. **Status Effect Stacking**: Define rules for buff/debuff interactions
8. **Combat Abandonment**: Auto-forfeit if all team members disconnect

---

## 🚀 Deployment Considerations

### Performance
- Use Redis for session state (faster than DB queries)
- Implement connection pooling for database
- Consider horizontal scaling with Redis pub/sub for cross-server combat

### Monitoring
```typescript
// Add metrics collection
import { Counter, Histogram } from 'prom-client';

const combatStartCounter = new Counter({
  name: 'combat_sessions_started_total',
  help: 'Total number of combat sessions started'
});

const actionProcessingTime = new Histogram({
  name: 'combat_action_processing_seconds',
  help: 'Time to process combat actions',
  buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5]
});
```

### Security
- Rate limit combat actions (max 1 per second per player)
- Validate all numeric inputs against bounds
- Sanitize combat messages before broadcasting
- Use transaction IDs to prevent replay attacks

### Database Indexes (Future)
```sql
-- When moving from mocks to DB
CREATE INDEX idx_combat_sessions_status ON combat_sessions(status);
CREATE INDEX idx_combat_participants_session ON combat_participants(session_id);
CREATE INDEX idx_combat_logs_session ON combat_logs(session_id, timestamp);
```

---

### 🔐 Self‑Audit Commands
```bash
npm run lint:ts --max-warnings=0
npm test --coverage -- --testPathPattern=combat
```
Paste: TS errors / Coverage %

### Progressive Enhancement Path
1. **Phase 1** (Current): Working API with mocked logic ✓
2. **Phase 2**: Real damage formulas, character stats from DB
3. **Phase 3**: Skills, items, status effects
4. **Phase 4**: PvP matchmaking, tournaments
5. **Phase 5**: Raid bosses, multi-stage encounters